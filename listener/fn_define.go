package listener

import (
	"github.com/elz-lang/elz/parser"
)

// EnterFnDefine listen FnDefine rule, when enter here, create a FnBuilder for following building routine
func (s *ElzListener) EnterFnDefine(ctx *parser.FnDefineContext) {
	fnBuilder := NewFnBuilder().
		Name(ctx.ID().GetText()).
		Export(s.exportThis).
		Notation(s.TakeAllNotation())
	s.statBuilder.Push(fnBuilder)
}

// EnterParamType listen parameter's type, emit it to FnBuilder
func (s *ElzListener) EnterParamType(ctx *parser.ParamTypeContext) {
	if fnBuilder, ok := s.statBuilder.Last().(*FnBuilder); !ok {
		panic("Compiler bug, function define expect have function builder when parsing")
	} else {
		fnBuilder.PushParamType(ctx.TypeForm().GetText())
	}
}

// EnterParam listen parameter rule, emit name of parameter to FnBuilder
func (s *ElzListener) EnterParam(ctx *parser.ParamContext) {
	if fnBuilder, ok := s.statBuilder.Last().(*FnBuilder); !ok {
		panic("Compiler bug, function define expect have function builder when parsing")
	} else {
		fnBuilder.PushParamName(ctx.ID().GetText())
	}
}

// EnterReturnType listen return form in function rule, emit return type to FnBuilder
func (s *ElzListener) EnterReturnType(ctx *parser.ReturnTypeContext) {
	if fnBuilder, ok := s.statBuilder.Last().(*FnBuilder); !ok {
		panic("Compiler bug, function define expect have function builder when parsing")
	} else {
		fnBuilder.RetType(ctx.TypeForm().GetText())
	}
}

// ExitFnDefine listen exit signal of rule FnDefine, emit function generated by FnBuilder to AstList
func (s *ElzListener) ExitFnDefine(ctx *parser.FnDefineContext) {
	if fnBuilder, ok := s.statBuilder.Last().(*FnBuilder); !ok {
		panic("Compiler bug, function define expect have function builder when parsing")
	} else {
		s.AstList = append(s.AstList,
			fnBuilder.Generate(false),
		)
		// Already leave function scope
		s.statBuilder.Pop()
	}
}
